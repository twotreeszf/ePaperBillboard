#!/usr/bin/env python3
"""
LVGL Binary Font Analyzer
Analyzes .bin font files generated by lv_font_conv
"""

import struct
import sys
from pathlib import Path


def read_table(f, tag):
    """Find and position at a table by tag name"""
    f.seek(0)
    while True:
        pos = f.tell()
        data = f.read(8)
        if len(data) < 8:
            return None
        length = struct.unpack('<I', data[:4])[0]
        name = data[4:8].decode('ascii', errors='ignore')
        if name == tag:
            return pos
        f.seek(pos + length)


def analyze_font(font_path, char='0'):
    """Analyze font file and extract glyph for specified character"""
    unicode_val = ord(char)
    
    with open(font_path, 'rb') as f:
        print(f"=== Analyzing: {font_path} ===")
        print(f"Target character: '{char}' (U+{unicode_val:04X})")
        print()
        
        # Parse HEAD table
        head_pos = read_table(f, 'head')
        if head_pos is None:
            print("ERROR: HEAD table not found")
            return
        
        # HEAD table data starts after length(4) + name(4) = offset 8
        head_data_start = head_pos + 8
        
        # Dump raw HEAD bytes for debugging
        f.seek(head_data_start)
        head_raw = f.read(40)
        print("=== HEAD Raw Bytes ===")
        print("  " + " ".join(f"{b:02X}" for b in head_raw[:20]))
        print("  " + " ".join(f"{b:02X}" for b in head_raw[20:40]))
        print()
        
        # Parse according to LVGL font format
        f.seek(head_data_start + 8)  # Skip first 8 bytes (version, etc.)
        ascent = struct.unpack('<H', f.read(2))[0]
        descent = struct.unpack('<h', f.read(2))[0]
        
        f.seek(head_data_start + 26)  # loc_format offset
        loc_format = struct.unpack('<B', f.read(1))[0]
        
        f.seek(head_data_start + 28)  # adv_format offset
        adv_format = struct.unpack('<B', f.read(1))[0]
        bpp = struct.unpack('<B', f.read(1))[0]
        bits_x_y = struct.unpack('<B', f.read(1))[0]
        bits_w_h = struct.unpack('<B', f.read(1))[0]
        bits_adv = struct.unpack('<B', f.read(1))[0]
        
        print("=== HEAD Table ===")
        print(f"  Ascent: {ascent}")
        print(f"  Descent: {descent}")
        print(f"  Line Height: {ascent - descent}")
        print(f"  Location Format: {loc_format}")
        print(f"  Advance Format: {adv_format}")
        print(f"  BPP: {bpp}")
        print(f"  Bits X/Y: {bits_x_y}")
        print(f"  Bits W/H: {bits_w_h}")
        print(f"  Bits Advance: {bits_adv}")
        print()
        
        # Parse CMAP table
        cmap_pos = read_table(f, 'cmap')
        if cmap_pos is None:
            print("ERROR: CMAP table not found")
            return
        
        f.seek(cmap_pos + 8)
        subtables_count = struct.unpack('<I', f.read(4))[0]
        
        print(f"=== CMAP Table ({subtables_count} subtables) ===")
        
        glyph_id = None
        for i in range(subtables_count):
            data_offset = struct.unpack('<I', f.read(4))[0]
            start_unicode = struct.unpack('<I', f.read(4))[0]
            length = struct.unpack('<H', f.read(2))[0]
            glyph_id_offset = struct.unpack('<H', f.read(2))[0]
            entries_count = struct.unpack('<H', f.read(2))[0]
            cmap_type = struct.unpack('<B', f.read(1))[0]
            f.read(1)  # padding
            
            end_unicode = start_unicode + length - 1
            print(f"  Subtable {i}: U+{start_unicode:04X}-U+{end_unicode:04X} (type={cmap_type}, gid_offset={glyph_id_offset})")
            
            # Check if our character is in this range
            if start_unicode <= unicode_val < start_unicode + length:
                offset = unicode_val - start_unicode
                if cmap_type == 2:
                    glyph_id = glyph_id_offset + offset
                elif cmap_type == 0:
                    # Read from data
                    save_pos = f.tell()
                    f.seek(cmap_pos + 8 + 4 + data_offset + offset)
                    glyph_id = glyph_id_offset + struct.unpack('<B', f.read(1))[0]
                    f.seek(save_pos)
                print(f"    -> Found '{char}' at offset {offset}, glyph_id = {glyph_id}")
        
        if glyph_id is None:
            print(f"\nERROR: Character '{char}' not found in font")
            return
        
        print()
        
        # Parse LOCA table
        loca_pos = read_table(f, 'loca')
        if loca_pos is None:
            print("ERROR: LOCA table not found")
            return
        
        f.seek(loca_pos + 8 + 4)  # Skip header
        
        if loc_format == 0:
            f.seek(loca_pos + 8 + 4 + glyph_id * 2)
            glyph_offset = struct.unpack('<H', f.read(2))[0]
        else:
            f.seek(loca_pos + 8 + 4 + glyph_id * 4)
            glyph_offset = struct.unpack('<I', f.read(4))[0]
        
        print(f"=== LOCA Table ===")
        print(f"  Glyph {glyph_id} offset: {glyph_offset}")
        print()
        
        # Parse GLYF table
        glyf_pos = read_table(f, 'glyf')
        if glyf_pos is None:
            print("ERROR: GLYF table not found")
            return
        
        f.seek(glyf_pos + 8 + glyph_offset)
        
        # Read glyph header using bit reader
        glyph_data = f.read(32)  # Read enough bytes
        
        def read_bits(data, bit_offset, num_bits):
            """Read bits from data starting at bit_offset"""
            result = 0
            for i in range(num_bits):
                byte_idx = (bit_offset + i) // 8
                bit_idx = 7 - ((bit_offset + i) % 8)
                if byte_idx < len(data):
                    if data[byte_idx] & (1 << bit_idx):
                        result |= (1 << (num_bits - 1 - i))
            return result
        
        def read_signed_bits(data, bit_offset, num_bits):
            """Read signed bits"""
            val = read_bits(data, bit_offset, num_bits)
            if val & (1 << (num_bits - 1)):
                val -= (1 << num_bits)
            return val
        
        bit_pos = 0
        adv_w = read_bits(glyph_data, bit_pos, bits_adv)
        bit_pos += bits_adv
        
        box_x = read_signed_bits(glyph_data, bit_pos, bits_x_y)
        bit_pos += bits_x_y
        
        box_y = read_signed_bits(glyph_data, bit_pos, bits_x_y)
        bit_pos += bits_x_y
        
        box_w = read_bits(glyph_data, bit_pos, bits_w_h)
        bit_pos += bits_w_h
        
        box_h = read_bits(glyph_data, bit_pos, bits_w_h)
        bit_pos += bits_w_h
        
        # Convert advance width if FP12.4 format
        if adv_format == 1:
            adv_w = (adv_w + 8) >> 4
        
        print(f"=== GLYF Data for '{char}' ===")
        print(f"  Advance Width: {adv_w}")
        print(f"  Box X (ofs_x): {box_x}")
        print(f"  Box Y: {box_y}")
        print(f"  Box Width: {box_w}")
        print(f"  Box Height: {box_h}")
        print(f"  Header bits: {bit_pos}")
        print()
        
        # Read and display bitmap
        if box_w > 0 and box_h > 0:
            print(f"=== Bitmap ({box_w}x{box_h}, {bpp}bpp) ===")
            
            for y in range(box_h):
                row = ""
                for x in range(box_w):
                    pixel = read_bits(glyph_data, bit_pos, bpp)
                    bit_pos += bpp
                    # Map to ASCII art
                    if bpp == 1:
                        row += "██" if pixel else "  "
                    else:
                        if pixel > 200:
                            row += "██"
                        elif pixel > 100:
                            row += "▓▓"
                        elif pixel > 50:
                            row += "░░"
                        else:
                            row += "  "
                print(f"  {row}")
        
        print()
        print("=== Done ===")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python analyze_font.py <font.bin> [character]")
        print("Example: python analyze_font.py data/fonts/ascii_48.bin 0")
        sys.exit(1)
    
    font_path = sys.argv[1]
    char = sys.argv[2] if len(sys.argv) > 2 else '0'
    
    if not Path(font_path).exists():
        print(f"ERROR: File not found: {font_path}")
        sys.exit(1)
    
    analyze_font(font_path, char)
